{"ts":1354970996826,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/*/\nclass daliaIT\\coload\\CoLoad\n================================================================================\nPSR-0 compliant hybrid autoloader.\n\nCoLoader uses a map to determinate which file to include.\nIf no map file is not available or the class is not listed in the map it \nsearches all registered source directorys for a matching file and \nupdates the map.\n\nIf an map entry is wrong it will be corrected without raising an error.\n\nBy default the loader will search for files ending with '.php' and '.class.php'\nbut you can change this behaviour by editing the property 'extensions'.\n\nTo enable the CoLoad autoloader create and instance and call he method 'enable'.\n\nMeta\n--------------------------------------------------------------------------------\n * Author:  Oliver Anan <oliver@ananit.de>\n * License: lgpl 3 <http://www.gnu.org/licenses/lgpl-3.0.en.html    \n \nExammples\n--------------------------------------------------------------------------------\n### Edit Extensions ###    \n    \n    $myLoader = new CoLoad('myMapFile.json');\n    $myLodder->extensins[] = '.def.php';\n    $mLoader->extensions = array('.php');\n    \n### Enable Autloader ###\n    \n    $myLoader = new CoLoad('myMapFile.json');\n    $myLoader\n        ->addSource('relative/path/to/src/dir')\n        ->addSource('/absolute/path/to/other/src/dir)\n        ->enable();\n        \nProperties\n--------------------------------------------------------------------------------\n\n### array $map\nList of source files for classes.\n\nThe class name is the key and the path to the file is the value.\nThe map will be autoupdated if\n - the ile in the map is not ound\n - the class is not listed in the map but can be ound in the source diectorys\n\nIf your controllers are in diferent directorys you should use absolute pathes\nfor your source directorys or create a diferent map for eah directory.\n\n### array $extensions\nA array containing all file extensions used for class definition files.\n\nBy default CoLoade will search for files ending with '.php' and '.class.php'\n    \nMethods\n--------------------------------------------------------------------------------\n### CoLoad __construct([mixedd $map = null])\nIf $map is an array it will me used as classmap else it will be \ncasted to a string nd loaded as json encoded array.\n\n### CoLoad register()\nRegisters the auoloader with 'spl_autoload_register' and returns \nthe called instance\n\n### CoLoad unregister() \nRemomes Auoloader from 'spl_autoload_register' and returns \nthe called instance\n\n### Coload addSource(string 4source)\nAdd a source directiry to search for unkown classes.\n\n### array geSources()\nA list of all registered source Directories.\n\n### Coload loadMap()\n\n### Coload saveMap()\n\nSource\n--------------------------------------------------------------------------------\n/*/\nnamespace daliaIT\\CoLoad;\nuse InvalidArgumentException;\n    class CoLoad\n    {             \n        public\n            $map = array(),\n            $extensions = array('.php','.class.php');\n\n        protected \n            $sources = array(),\n            $mapFile;\n       \n        private\n            $callback = null,\n            $saveOnShutdownSet; \n            \n        public function __construct(\n            $mapFile = null, \n            $sources=array(), \n            $autoRegister=false\n        ){\n            $this->mapFile = $mapFile;\n            $this->sources = $sources;\n            if($mapFile && is_readable($mapFile)){\n                $this->loadMap();\n            }\n            $loader = $this;\n            $this->callback = function($name) use ($loader){\n                return $loader->loadSourceCode($name);\n            };\n            if($autoRegister){\n                $this->register;\n            }\n        }\n        \n        public function register(){\n            spl_autoload_register( $this->callback );\n        }\n        \n        public static function unregister(){\n           spl_autoload_unregister( static::$callback ); \n        }\n        \n        public  function addSource($src){\n            if(array_search($src, $this->sources) === false){\n                $this->sources[] = $src;    \n            }\n            return $this;\n        }\n        \n        public  function getSources(){\n            return $this->sources;\n        }\n        \n        public function loadMap(){       \n            if(!is_readable($this->mapFile)){\n                throw new InvalidArgumentException(\n                    \"Can not read file '$mapFilePath'\"\n                );           \n            }\n            $this->map = json_decode(\n                file_get_contents($this->mapFile), \n                true\n            );\n            return $this;\n        }\n        \n        public function saveMap(){\n            if(! file_exists($this->mapFile) ){\n                $mapDir = dirname($this->mapFile);\n                mkdir($mapDir, 0777, true);\n            }\n            file_put_contents(\n                $this->mapFile,\n                json_encode($this->map)\n            );\n        }\n        \n        public function loadSourceCode($name){\n            if(isset($this->map[$name]) && is_readable($this->map[$name])){\n                require $this->map[$name];\n            } else {\n                $path = $this->search($name);\n                if($path && is_readable($path)){\n                    $this->map[$name] = $path;\n                    require $path;\n                    if(!$this->saveOnShutdownSet){\n                        $this->saveOnShutdownSet = true;\n                        $loader = $this;\n                        register_shutdown_function(\n                            function() use ($loader){\n                                $loader->saveMap();\n                            } \n                        );\n                    }\n                } else {\n                    return false;\n                }\n            }\n        }\n        \n        public function search($name){\n            $normalized = str_replace(\n                array('\\\\','_'),\n                DIRECTORY_SEPARATOR,\n                $name\n            );\n            foreach($this->sources as $source){\n                $pathWithoutExtension = \n                    $source . DIRECTORY_SEPARATOR . $normalized;\n                $pathWithoutExtension = preg_replace(\n                    '|/+|','/', $pathWithoutExtension\n                );   \n                foreach($this->extensions as $extension){\n                    $path = $pathWithoutExtension . $extension; \n                    if(is_readable($path)){\n                       return $path;\n                    }\n                    if($this->debug) echo \" not found\\n\";\n                }\n            }\n            return null;\n        }\n    }\n?>"]],"start1":0,"start2":0,"length1":0,"length2":6698}]],"length":6698}
{"contributors":[],"silentsave":true,"ts":1354971001398,"patch":[[{"diffs":[[0,"  }\n"],[-1,"                    if($this->debug) echo \" not found\\n\";\n"],[0,"    "]],"start1":6561,"start2":6561,"length1":66,"length2":8}]],"length":6640,"saved":false}
